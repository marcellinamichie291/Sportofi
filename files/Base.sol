// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "@openzeppelin/contracts/utils/Context.sol";

import "../interfaces/IAuthority.sol";

import "../libraries/Roles.sol";

abstract contract Base {
    bytes32 private _authority;

    modifier onlyRole(bytes32 role) {
        _checkRole(role, msg.sender);
        _;
    }

    modifier onlyWhitelisted() {
        _checkBlacklist(msg.sender);
        _;
    }

    modifier whenNotPaused() {
        _requireNotPaused();
        _;
    }

    modifier whenPaused() {
        _requirePaused();
        _;
    }

    event AuthorityUpdated(IAuthority indexed from, IAuthority indexed to);

    constructor(IAuthority authority_, bytes32 role_) payable {
        if (role_ != 0) authority_.requestAccess(role_);
        __updateAuthority(authority_);
    }

    function updateAuthority(IAuthority authority_)
        external
        onlyRole(Roles.OPERATOR_ROLE)
    {
        IAuthority old = authority();
        require(old != authority_, "BASE: ALREADY_SET");
        __updateAuthority(authority_);
        emit AuthorityUpdated(old, authority_);
    }

    function authority() public view returns (IAuthority authority_) {
        /// @solidity memory-safe-assembly
        assembly {
            authority_ := sload(_authority.slot)
        }
    }

    function _checkBlacklist(address account_) internal view {
        require(!authority().isBlacklisted(account_), "BASE: BLACKLISTED");
    }

    function _checkRole(bytes32 role_, address account_) internal view {
        require(authority().hasRole(role_, account_), "BASE: UNAUTHORIZED");
    }

    function __updateAuthority(IAuthority authority_) internal {
        /// @solidity memory-safe-assembly
        assembly {
            sstore(_authority.slot, authority_)
        }
    }

    function _requirePaused() internal view {
        require(authority().paused(), "BASE: NOT_PAUSED");
    }

    function _requireNotPaused() internal view {
        require(!authority().paused(), "BASE: PAUSED");
    }

    function _hasRole(bytes32 role_, address account_)
        internal
        view
        returns (bool)
    {
        return authority().hasRole(role_, account_);
    }
}
